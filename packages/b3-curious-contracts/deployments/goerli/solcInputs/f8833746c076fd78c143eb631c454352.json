{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/Battleship.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.17;\n\n/**\n * @title onchain battleship\n * @author @Da-Colon (github)\n */\ncontract Battleship {\n    event TeamReady(address team);\n    event TurnFinished(address team, bytes4 target, bool isSuccessful);\n    event GameFinished(address winner);\n\n    address public game_winner = address(0);\n    address public teamOne = address(0);\n    address public teamTwo = address(0);\n    address public currentTurn = address(0);\n\n    mapping(address => bool) private teamReady;\n    mapping(address => mapping(bytes4 => uint8)) private locations;\n    mapping(address => TeamHits) private teamHits;\n\n    struct TeamHits {\n        uint8 hitCount;\n        mapping(bytes4 => uint8) targeted;\n    }\n\n    modifier piecesSet(bool isReady) {\n        require(teamReady[msg.sender] == isReady, \"Pieces Set\");\n        _;\n    }\n\n    modifier gameOver() {\n        require(game_winner == address(0), \"Game is Over\");\n        _;\n    }\n\n    modifier checkTurn() {\n        if ((currentTurn == address(0) && msg.sender == teamTwo)) {\n            _;\n            return;\n        }\n        require(currentTurn == msg.sender, \"Not your turn\");\n        _;\n    }\n\n    function checkAndSetPieces(\n        bytes4[15] memory targets,\n        address team\n    ) private {\n        for (uint256 i; i < targets.length; i++) {\n            locations[team][targets[i]] = 1;\n        }\n        teamReady[team] = true;\n        emit TeamReady(team);\n    }\n\n    function setTeamOnePieces(\n        bytes4[15] memory targets\n    ) external piecesSet(false) {\n        require(msg.sender == teamOne, \"Team One Only\");\n        checkAndSetPieces(targets, msg.sender);\n    }\n\n    function setTeamTwoPieces(\n        bytes4[15] memory targets\n    ) external piecesSet(false) {\n        require(msg.sender == teamTwo, \"Team Two Only\");\n        checkAndSetPieces(targets, msg.sender);\n    }\n\n    function targetSpot(bytes4 target, address defTeam) private gameOver {\n        if (\n            locations[defTeam][target] == 1 &&\n            teamHits[msg.sender].targeted[target] == 0\n        ) {\n            uint8 raisedHit = ++teamHits[msg.sender].hitCount;\n            teamHits[msg.sender].hitCount = raisedHit;\n            teamHits[msg.sender].targeted[target] = 1;\n            if (raisedHit == 15) {\n                game_winner = msg.sender;\n                emit GameFinished(msg.sender);\n            } else {\n                emit TurnFinished(msg.sender, target, true);\n            }\n        } else {\n            emit TurnFinished(msg.sender, target, false);\n        }\n\n        currentTurn = defTeam;\n    }\n\n    function takeTurn(bytes4 target) external piecesSet(true) checkTurn {\n        if (msg.sender == teamOne) {\n            targetSpot(target, teamTwo);\n        } else {\n            targetSpot(target, teamOne);\n        }\n    }\n\n    function init(address _teamOne, address _teamTwo) public {\n        teamOne = _teamOne;\n        teamTwo = _teamTwo;\n    }\n}\n"
    },
    "contracts/BattleshipFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./Battleship.sol\";\n\ncontract BattleshipFactory {\n    event GameCreated(address gameAddress, address teamOne, address teamTwo);\n\n    uint private gameId;\n    address private BattleshipAddr;\n\n    // gameId -> contract implementation\n    mapping(uint => Battleship) BattleshipGames;\n\n    modifier uniqueTeams(address teamTwo) {\n        require(msg.sender != teamTwo);\n        _;\n    }\n\n    function deployAndChallange(address teamTwo) external uniqueTeams(teamTwo) {\n        Battleship newGame = Battleship(\n            Clones.clone(BattleshipAddr)\n        );\n        newGame.init(msg.sender, teamTwo);\n        BattleshipGames[gameId] = newGame;\n        gameId = ++gameId;\n        emit GameCreated(address(newGame), msg.sender, teamTwo);\n    }\n\n    constructor(address implAddress) {\n        BattleshipAddr = implAddress;\n    }\n\n    function getGames() public view returns (Battleship[] memory) {\n        Battleship[] memory games = new Battleship[](gameId);\n        for (uint i = 0; i < gameId; i++) {\n            games[i] = BattleshipGames[i];\n        }\n        return games;\n    }\n}\n"
    },
    "contracts/ConnectFour.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.17;\n\ncontract ConnectFour {\n    /// @notice revert if caller isn't current team\n    error NotYourTurn();\n    /// @notice revert if column choice is invalid\n    error InvalidSelection();\n    /// @notice revert if game has been completed\n    error GameOver();\n    /// @notice revert season is over (coming soon)\n    error SeasonOver();\n\n    /// @notice emiited when game is created\n    event GameCreated(uint8 gameId, address teamOne, address teamTwo);\n    /// @notice emitted after turn is successfully taken\n    event TurnTaken(address team, uint8 column);\n    /// @notice emitted when game is complete\n    event GameFinished(address winner, uint8 gameId);\n\n    /// @notice holds game data\n    /// @param teamOne address of challenger\n    /// @param teamTwo address of challenged\n    /// @param winner address of winning team; default: address(0)\n    /// @param turn current turn is calculated using bitwise for basically odd/even teamOne/teamTwo\n    /// @param board holds game board data; each 'square' holds current data; 0 = no chip; 1 = team one; 2 = team two\n    struct Game {\n        address teamOne;\n        address teamTwo;\n        address winner;\n        uint8 turn;\n        uint8[6][6] board;\n    }\n\n    /// @notice Used as a counter for the next game index.\n    /// @dev Initialised at 1 because it makes the first transaction slightly cheaper.\n    uint8 internal gameId = 1;\n\n    /// @notice An indexed list of games\n    /// @dev This automatically generates a getter for us, which will return `Game.player1`, `Game.player2`, `Game.moves`, and `Game.finished` (the arrays are skipped)\n    mapping(uint8 => Game) public getGame;\n\n    /// @notice prevent move if column is invalid\n    modifier validColumn(uint8 column) {\n        if (column >= 6) revert InvalidSelection();\n        _;\n    }\n\n    /// @notice prevents gameplay if game is over\n    modifier gameOver(uint8 _gameId) {\n        if (getGame[_gameId].winner != address(0)) revert GameOver();\n        _;\n    }\n\n    /// @notice prevents new games when season is over. (coming soon)\n    modifier seasonOver() {\n        _;\n    }\n\n    /// @notice prevents teams being the same address\n    modifier uniqueTeams(address opponent) {\n        require(msg.sender != opponent);\n        _;\n    }\n\n    /**\n     * @notice challenge an address to a game of connect four\n     * @param opponent challened\n     * @dev opponent will go first\n     * @dev game id is increated each time a new game is created\n     * @dev season is over when timer (soon to be added) is past\n     */\n    function challenge(\n        address opponent\n    ) public uniqueTeams(opponent) returns (uint8) {\n        uint8[6][6] memory newBoard;\n        Game memory newGame = Game({\n            teamOne: msg.sender,\n            teamTwo: opponent,\n            turn: uint8(0),\n            winner: address(0),\n            board: newBoard\n        });\n\n        getGame[gameId] = newGame;\n\n        emit GameCreated(gameId, msg.sender, opponent);\n\n        return gameId++;\n    }\n\n    /**\n     * @notice current team plays a turn\n     * @param _gameId id of game\n     * @param column selected column for move\n     */\n    function makeMove(\n        uint8 _gameId,\n        uint8 column\n    ) external gameOver(_gameId) validColumn(column) {\n        Game storage game = getGame[_gameId];\n\n        /// @notice row where chip will land\n        uint8 row;\n        /// @notice assigned team number for squares\n        uint8 teamNum = game.turn & 1 == 0 ? 2 : 1;\n\n        /// @notice prevents plays being made by other addresses\n        /// @dev even or odd bitwise operator decides turn\n        /// @dev starts with team two\n        if (msg.sender != (game.turn & 1 == 0 ? game.teamTwo : game.teamOne)) {\n            revert NotYourTurn();\n        }\n\n        /// @notice finds where chip will land\n        for (uint8 i = 0; i < 6; i++) {\n            uint8 square = game.board[column][i];\n            if (i == 5) {\n                revert InvalidSelection();\n            }\n            if (square == 0) {\n                row = i++;\n                break;\n            }\n        }\n\n        /// @notice assigns chip to location onboard\n        game.board[column][row] = teamNum;\n        /// @notice increments turn\n        game.turn++;\n\n        emit TurnTaken(msg.sender, column);\n\n        /// @notice checks surrounding squares for connected pieces\n        if (didPlayerWin(_gameId, column, row, teamNum)) {\n            game.winner = msg.sender;\n            emit GameFinished(msg.sender, _gameId);\n        }\n    }\n\n    /// @notice checks square for team's chip\n    /// @param board game board data\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkSquare(\n        uint8[6][6] storage board,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (bool) {\n        return board[column][row] == teamNum;\n    }\n\n    /// @notice checks the horizontal win\n    /// @param board game board data\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkHorizonalWin(\n        uint8[6][6] storage board,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (uint8) {\n        uint8 connectedPiecesCount = 1;\n\n        /// @dev checks to the right of new piece\n        for (uint8 i = column + 1; i < 6 - column; i++) {\n            if (checkSquare(board, i, row, teamNum)) {\n                connectedPiecesCount++;\n            } else {\n                break;\n            }\n        }\n        /// @dev checks to the left of new piece\n        if (column != 0) {\n            uint8 columnIndex = column - 1;\n            while (columnIndex >= 0) {\n                if (checkSquare(board, columnIndex, row, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (columnIndex == 0) {\n                    break;\n                } else {\n                    columnIndex--;\n                }\n            }\n        }\n        return connectedPiecesCount;\n    }\n\n    /// @notice checks the veritical win\n    /// @param board game board data\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkVericalWin(\n        uint8[6][6] storage board,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (uint8) {\n        uint8 connectedPiecesCount = 1;\n\n        /// @dev checks rows above new piece\n        for (uint8 i = row + 1; i < 6 - row; i++) {\n            if (checkSquare(board, column, i, teamNum)) {\n                connectedPiecesCount++;\n            } else {\n                break;\n            }\n        }\n        /// @dev checks rows below new piece\n        if (row != 0) {\n            uint8 rowIndex = row - 1;\n            while (rowIndex >= 0) {\n                if (checkSquare(board, column, rowIndex, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (rowIndex == 0) {\n                    break;\n                } else {\n                    rowIndex--;\n                }\n            }\n        }\n        return connectedPiecesCount;\n    }\n\n    /// @notice checks the forward angle win\n    /// @param board game board data\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkForwardAngleWin(\n        uint8[6][6] storage board,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (uint8) {\n        uint8 connectedPiecesCount = 1;\n\n        /// @dev checks forward angle up\n        for (uint8 i = row + 1; i < 6 - row; i++) {\n            if (checkSquare(board, i, i, teamNum)) {\n                connectedPiecesCount++;\n            } else {\n                break;\n            }\n        }\n\n        /// @dev checks forward angle down\n        if (row != 0 && column != 0) {\n            uint8 rowIndex = row - 1;\n            uint8 columnIndex = column - 1;\n            while (rowIndex >= 0 || columnIndex >= 0) {\n                if (checkSquare(board, columnIndex, rowIndex, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (rowIndex == 0 || columnIndex == 0) {\n                    break;\n                } else {\n                    rowIndex--;\n                    columnIndex--;\n                }\n            }\n        }\n        return connectedPiecesCount;\n    }\n\n    /// @notice checks the backward angle win\n    /// @param board game board data\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkBackwardAngleWin(\n        uint8[6][6] storage board,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (uint8) {\n        uint8 connectedPiecesCount = 1;\n\n        /// @dev checks backward angle down\n        if (row != 0 && column != 0) {\n            uint8 rowIndex = row - 1;\n            uint8 columnIndex = column + 1;\n            while (rowIndex >= 0 || columnIndex < 7) {\n                if (checkSquare(board, columnIndex, rowIndex, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (rowIndex == 0 || columnIndex > 6) {\n                    break;\n                } else {\n                    rowIndex--;\n                    columnIndex++;\n                }\n            }\n        }\n\n        /// @dev checks forward angle down\n        if (row != 0 && column != 0) {\n            uint8 rowIndex = row + 1;\n            uint8 columnIndex = column - 1;\n            while (rowIndex < 7 || columnIndex >= 0) {\n                if (checkSquare(board, columnIndex, rowIndex, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (rowIndex > 6 || columnIndex == 0) {\n                    break;\n                } else {\n                    rowIndex++;\n                    columnIndex--;\n                }\n            }\n        }\n        return connectedPiecesCount;\n    }\n\n    /// @notice checks to see if current play won the game\n    function didPlayerWin(\n        uint8 _gameId,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (bool) {\n        uint8[6][6] storage board = getGame[_gameId].board;\n        /// @dev using new chip location as middle == m\n        /// @dev [ [ C+1 | R-1 ] [  C+1  ] [ C+1 | R+1 ] ]\n        /// @dev [ [    R-1    ] [ C | R ] [    R+1    ]\n        /// @dev [ [ C-1 | R-1 ] [  C-1  ] [ C-1 | R+1 ] ]\n\n        uint8 horionalCount = checkHorizonalWin(board, column, row, teamNum);\n        if (horionalCount == 4) {\n            return true;\n        }\n        uint8 vericalCount = checkVericalWin(board, column, row, teamNum);\n        if (vericalCount == 4) {\n            return true;\n        }\n        uint8 forwardAngleCount = checkForwardAngleWin(\n            board,\n            column,\n            row,\n            teamNum\n        );\n        if (forwardAngleCount == 4) {\n            return true;\n        }\n        uint8 backwardAngleCount = checkBackwardAngleWin(\n            board,\n            column,\n            row,\n            teamNum\n        );\n        if (backwardAngleCount == 4) {\n            return true;\n        }\n        return false;\n    }\n\n    function getGameBoard(\n        uint8 _gameId\n    ) public view returns (uint8[6][6] memory) {\n        return getGame[_gameId].board;\n    }\n}\n"
    },
    "contracts/ConnectFourFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./ConnectFour.sol\";\n\ncontract ConnectFourFactory {\n    event NewConnectFourSeasonCreated(uint8 seasonId, address gameAddress);\n\n    uint8 private seasonId;\n    address private connectFourImplAddr;\n\n    // gameId -> contract implementation\n    mapping(uint8 => ConnectFour) public connectFourGames;\n\n    function deployNewSeason() public returns (uint8) {\n        ConnectFour newGame = ConnectFour(Clones.clone(connectFourImplAddr));\n        connectFourGames[seasonId] = newGame;\n\n        emit NewConnectFourSeasonCreated(seasonId, address(newGame));\n\n        return seasonId++;\n    }\n\n    constructor(address implAddress) {\n        connectFourImplAddr = implAddress;\n    }\n\n    function getGames() public view returns (ConnectFour[] memory) {\n        ConnectFour[] memory games = new ConnectFour[](seasonId);\n        for (uint8 i = 0; i < seasonId; i++) {\n            games[i] = connectFourGames[i];\n        }\n        return games;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}